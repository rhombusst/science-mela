#include <WiFiS3.h>
#include <WebServer.h>
#include <TinyGPS++.h>

// Replace with your WiFi credentials
const char* ssid = "YOUR_WIFI_SSID";
const char* password = "YOUR_WIFI_PASSWORD";

// Arduino UNO R4 pins (change as per wiring)
#define MOTOR_FWD   2
#define MOTOR_BACK  3
#define MOTOR_LEFT  4
#define MOTOR_RIGHT 5
#define ANCHOR_PIN  6
#define LIGHTS_PIN  7
#define HORN_PIN    8
#define PH_SENSOR   A0   // pH sensor analog pin

WebServer server(80);

// GPS setup
TinyGPSPlus gps;
HardwareSerial GPSSerial(1); // use Serial1 (pins 0=TX, 1=RX on UNO R4)

// Calibration parameters for pH sensor
float calibration_offset = 0.0; // shifts reading
float calibration_slope  = 1.0; // scales reading

// Stop all motors
void stopAll() {
  digitalWrite(MOTOR_FWD, LOW);
  digitalWrite(MOTOR_BACK, LOW);
  digitalWrite(MOTOR_LEFT, LOW);
  digitalWrite(MOTOR_RIGHT, LOW);
}

void setup() {
  Serial.begin(115200);
  GPSSerial.begin(9600); // GPS modules usually use 9600 baud

  // Connect to WiFi
  Serial.print("Connecting to WiFi: ");
  Serial.println(ssid);
  WiFi.begin(ssid, password);

  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
    attempts++;
    if (attempts > 20) {  // ~10s timeout
      Serial.println("\nFailed to connect. Restarting...");
      NVIC_SystemReset(); // reset UNO R4
    }
  }

  Serial.println("\nWiFi connected!");
  Serial.print("IP Address: ");
  Serial.println(WiFi.localIP());

  // Setup pins
  pinMode(MOTOR_FWD, OUTPUT);
  pinMode(MOTOR_BACK, OUTPUT);
  pinMode(MOTOR_LEFT, OUTPUT);
  pinMode(MOTOR_RIGHT, OUTPUT);
  pinMode(ANCHOR_PIN, OUTPUT);
  pinMode(LIGHTS_PIN, OUTPUT);
  pinMode(HORN_PIN, OUTPUT);

  stopAll();

  // ================= ROUTES =================

  server.on("/", []() {
    server.send(200, "text/plain", "Smart IoT Boat - Arduino UNO R4 Online");
  });

  server.on("/forward", []() {
    stopAll();
    digitalWrite(MOTOR_FWD, HIGH);
    server.send(200, "text/plain", "Forward");
  });

  server.on("/back", []() {
    stopAll();
    digitalWrite(MOTOR_BACK, HIGH);
    server.send(200, "text/plain", "Backward");
  });

  server.on("/left", []() {
    stopAll();
    digitalWrite(MOTOR_LEFT, HIGH);
    server.send(200, "text/plain", "Left");
  });

  server.on("/right", []() {
    stopAll();
    digitalWrite(MOTOR_RIGHT, HIGH);
    server.send(200, "text/plain", "Right");
  });

  server.on("/stop", []() {
    stopAll();
    server.send(200, "text/plain", "Stopped");
  });

  server.on("/anchor", []() {
    digitalWrite(ANCHOR_PIN, !digitalRead(ANCHOR_PIN));
    server.send(200, "text/plain", "Anchor toggled");
  });

  server.on("/lights", []() {
    digitalWrite(LIGHTS_PIN, !digitalRead(LIGHTS_PIN));
    server.send(200, "text/plain", "Lights toggled");
  });

  server.on("/horn", []() {
    digitalWrite(HORN_PIN, HIGH);
    delay(500);
    digitalWrite(HORN_PIN, LOW);
    server.send(200, "text/plain", "Horn");
  });

  // ================= pH Sensor =================
  server.on("/ph", []() {
    int sensorValue = analogRead(PH_SENSOR);
    float voltage = sensorValue * (5.0 / 1023.0); // UNO R4 ADC = 0â€“5V
    float raw_pH = 7 + ((2.5 - voltage) / 0.18);

    // Apply calibration
    float calibrated_pH = (raw_pH * calibration_slope) + calibration_offset;

    String phStatus;
    if (calibrated_pH < 7.0) phStatus = "Acidic";
    else if (calibrated_pH > 7.0) phStatus = "Alkaline";
    else phStatus = "Neutral";

    String response = "pH: " + String(calibrated_pH, 2) + " (" + phStatus + ")";
    server.send(200, "text/plain", response);
  });

  // Set calibration parameters
  server.on("/set_calibration", []() {
    if (server.hasArg("offset")) {
      calibration_offset = server.arg("offset").toFloat();
    }
    if (server.hasArg("slope")) {
      calibration_slope = server.arg("slope").toFloat();
    }

    String response = "Calibration updated -> offset: " + String(calibration_offset) +
                      ", slope: " + String(calibration_slope);
    server.send(200, "text/plain", response);
  });

  // ================= GPS =================
  server.on("/gps", []() {
    while (GPSSerial.available() > 0) {
      gps.encode(GPSSerial.read());
    }

    if (gps.location.isUpdated()) {
      String gpsData = "Lat: " + String(gps.location.lat(), 6) +
                       ", Lng: " + String(gps.location.lng(), 6) +
                       ", Sat: " + String(gps.satellites.value());
      server.send(200, "text/plain", gpsData);
    } else {
      server.send(200, "text/plain", "Waiting for GPS signal...");
    }
  });

  // Handle unknown routes
  server.onNotFound([]() {
    server.send(404, "text/plain", "Not Found");
  });

  server.begin();
  Serial.println("HTTP server started");
}

void loop() {
  server.handleClient();

  // Keep reading GPS data in background
  while (GPSSerial.available() > 0) {
    gps.encode(GPSSerial.read());
  }
}
